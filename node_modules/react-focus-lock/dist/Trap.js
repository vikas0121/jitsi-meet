'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.onFocus = exports.onBlur = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactClientsideEffect = require('react-clientside-effect');

var _reactClientsideEffect2 = _interopRequireDefault(_reactClientsideEffect);

var _focusLock = require('focus-lock');

var _focusLock2 = _interopRequireDefault(_focusLock);

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var focusOnBody = function focusOnBody() {
  return document && document.activeElement === document.body;
};

var isFreeFocus = function isFreeFocus() {
  return focusOnBody() || (0, _focusLock.focusIsHidden)();
};

var lastActiveTrap = null;
var lastActiveFocus = null;

var lastPortaledElement = null;

var defaultWhitelist = function defaultWhitelist() {
  return true;
};

var focusWhitelisted = function focusWhitelisted(activeElement) {
  return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);
};

var recordPortal = function recordPortal(observerNode, portaledElement) {
  lastPortaledElement = { observerNode: observerNode, portaledElement: portaledElement };
};

var focusIsPortaledPair = function focusIsPortaledPair(element) {
  return lastPortaledElement && lastPortaledElement.portaledElement === element;
};

var activateTrap = function activateTrap() {
  var result = false;
  if (lastActiveTrap) {
    var _lastActiveTrap = lastActiveTrap,
        observed = _lastActiveTrap.observed,
        onActivation = _lastActiveTrap.onActivation,
        persistentFocus = _lastActiveTrap.persistentFocus,
        autoFocus = _lastActiveTrap.autoFocus;

    var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
    var activeElement = document && document.activeElement;

    if (!activeElement || focusWhitelisted(activeElement)) {
      if (persistentFocus || !isFreeFocus() || !lastActiveFocus && autoFocus) {
        if (workingNode && !((0, _focusLock.focusInside)(workingNode) || focusIsPortaledPair(activeElement, workingNode))) {
          onActivation();
          if (document && !lastActiveFocus && activeElement && !autoFocus) {
            activeElement.blur();
            document.body.focus();
          } else {
            result = (0, _focusLock2.default)(workingNode, lastActiveFocus);
            lastPortaledElement = {};
          }
        }
        lastActiveFocus = document && document.activeElement;
      }
    }
  }
  return result;
};

var onTrap = function onTrap(event) {
  if (activateTrap() && event) {
    // prevent scroll jump
    event.stopPropagation();
    event.preventDefault();
  }
};

var onBlur = exports.onBlur = function onBlur() {
  return (0, _util.deferAction)(activateTrap);
};

var onFocus = exports.onFocus = function onFocus(event) {
  // detect portal
  var source = event.target;
  var currentNode = event.currentTarget;
  if (!currentNode.contains(source)) {
    recordPortal(currentNode, source);
  }
};

var FocusWatcher = function FocusWatcher() {
  return null;
};

var FocusTrap = function FocusTrap(_ref) {
  var children = _ref.children;
  return _react2.default.createElement(
    'div',
    { onBlur: onBlur, onFocus: onFocus },
    children
  );
};

FocusTrap.propTypes = {
  children: _propTypes2.default.node.isRequired
};

var attachHandler = function attachHandler() {
  document.addEventListener('focusin', onTrap, true);
  document.addEventListener('focusout', onBlur);
};

var detachHandler = function detachHandler() {
  document.removeEventListener('focusin', onTrap, true);
  document.removeEventListener('focusout', onBlur);
};

function reducePropsToState(propsList) {
  return propsList.filter(function (_ref2) {
    var disabled = _ref2.disabled;
    return !disabled;
  }).slice(-1)[0];
}

function handleStateChangeOnClient(trap) {
  if (trap && !lastActiveTrap) {
    attachHandler();
  }

  lastActiveTrap = trap;
  if (trap) {
    lastActiveFocus = null;
    activateTrap(true);
    (0, _util.deferAction)(activateTrap);
  } else {
    detachHandler();
    lastActiveFocus = null;
  }
}

exports.default = (0, _reactClientsideEffect2.default)(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);